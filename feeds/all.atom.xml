<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Gioacchino's Radio Shack</title><link href="https://castogio.github.io/" rel="alternate"></link><link href="https://castogio.github.io/feeds/all.atom.xml" rel="self"></link><id>https://castogio.github.io/</id><updated>2023-08-05T00:07:00+01:00</updated><entry><title>Effective Isotropic Radiated Power (EIRP) explained</title><link href="https://castogio.github.io/effective-isotropic-radiated-power-eirp-explained.html" rel="alternate"></link><published>2023-08-05T00:07:00+01:00</published><updated>2023-08-05T00:07:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-08-05:/effective-isotropic-radiated-power-eirp-explained.html</id><summary type="html">&lt;p&gt;In this post, I would like to discuss a topic that, surprisingly, has kept
coming over and over in the discussions with my customers: the difference
between the concepts of Transmit (TX) Power and the Effective Isotropic
Radiated Power (EIRP). People tend to confuse the two terms and this
create …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post, I would like to discuss a topic that, surprisingly, has kept
coming over and over in the discussions with my customers: the difference
between the concepts of Transmit (TX) Power and the Effective Isotropic
Radiated Power (EIRP). People tend to confuse the two terms and this
create a lot of headaches when it comes to troubleshooting tickets relating to
poor signal quality.&lt;/p&gt;
&lt;h2&gt;Glossary&lt;/h2&gt;
&lt;p&gt;Let's clarify immediately some of the terms that will show up later in the post:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TX Power&lt;/strong&gt;: it is the amount of power measured in Watts (W) at the output 
   of a transmitter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loss/Attenuation&lt;/strong&gt;: it is the decrease of strength in a signal propagating
  through a physical medium. An example is Free-Space Path Loss (FSPL) is
  observed at the receiver after the signal propagates through free space
  (normally air) and it increases with the distance between the transmitter and 
  the receiver. Cables and waveguides introduce losses.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- - **Intentional Radiator** (IR): as defined in the FCC Code of Federal
  Regulations (CFR) Part 15, an IR is a device that _intentionally_ generates and
  emits radio frequency energy by radiation or induction. This broad definition 
  is better understood by negation. Something that emits RF
  energy as a byproduct of its internal operations without explicitly being
  designed to do so does not qualify as an IR. An Access Point (AP) is an IR, 
  while a rotating coil generating in a factory causing interference is not an IR. --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Isotropic Antenna&lt;/strong&gt;: it is a point antenna transmitting, and receiving, 
  signal equally in all directions. It is impossible to create such 
  an antenna in real life, so we use it as a reference.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Antenna Gain&lt;/h2&gt;
&lt;p&gt;The Antenna Gain is the increase in transmitted (or received) signal
strength due to the antenna focusing the RF energy towards a direction. 
This gain is passive as the antenna does not add more external power to the
signal as an RF amplifier would (i.e. we do not need to power up an antenna). 
The direction of maximum gain is usually called &lt;em&gt;Antenna Boresight&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;The gain G is an adimensional scalar computed as a ratio:&lt;/p&gt;
&lt;!-- 
    https://latexeditor.lagrida.com/
    G = \frac{P_{rx}}{P_{rx,i}}
--&gt;

&lt;p&gt;&lt;center&gt;
    &lt;img alt="Antenna Gain definition" src="https://castogio.github.io/images/eirp_explained/gain_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;where P&lt;sub&gt;rx,i&lt;/sub&gt; is the power of a sample signal received at an isotropic
antenna, while P&lt;sub&gt;rx&lt;/sub&gt; is the power of the same sample signal received
at the antenna for which we are computing the gain. The Wikipedia article 
describing &lt;a href="https://en.wikipedia.org/wiki/Gain_(antenna)"&gt;Atenna Gains&lt;/a&gt; 
shows the image below (public domain) to represent how a directional antenna
radiates the same power as an isotropic radiator while focusing it on a specific
direction:&lt;/p&gt;
&lt;!-- https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Antenna_directive_gain_diagram.svg/2560px-Antenna_directive_gain_diagram.svg.png --&gt;

&lt;p&gt;&lt;center&gt;
    &lt;img alt="Wikipedia Antenna Gain example" src="https://castogio.github.io/images/eirp_explained/wikipedia_antenna_gain_image.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;In the logarithmic scale, the gain is expressed in &lt;em&gt;dBi&lt;/em&gt; (with 0 dBi meaning
that the antenna is isotropic as the ratio equals 1).&lt;/p&gt;
&lt;h2&gt;Computing the EIRP&lt;/h2&gt;
&lt;p&gt;In my previous blog post &lt;a href="https://castogio.github.io/introduction-to-rx-sop-configuration.html"&gt;Introduction to RX-SOP Configuration&lt;/a&gt;, I already described at a high level how to compute the power at the
receiver (RX) when the only relevant effect is FSPL, but I abused the 
notation P&lt;sub&gt;tx&lt;/sub&gt; to refer to the power at the transmitter antenna.
I should have used the EIRP, which is defined as follows:&lt;/p&gt;
&lt;!-- 
    https://latexeditor.lagrida.com/
    EIRP=\frac{P_{TX}*G_{tx,i}*G_{txbf}}{L_c} 
--&gt;

&lt;p&gt;&lt;center&gt;
    &lt;img alt="EIRP definition (linear scale)" src="https://castogio.github.io/images/eirp_explained/eirp_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;where P&lt;sub&gt;TX&lt;/sub&gt; is the TX Power, G&lt;sub&gt;tx,i&lt;/sub&gt; is the transmit antenna
gain with respect to the isotropic antenna, G&lt;sub&gt;txbf&lt;/sub&gt; is the transmit 
beamforming gain, and L&lt;sub&gt;c&lt;/sub&gt; is the loss due to the cable between the 
transmitter and the antenna. The beamforming gain is obtained in a 
Multiple-Input Multiple-Output (MIMO) system that focuses the RF power on a specific direction
combining the effect of multiple antennas transmitting at the same time with a 
constructive effect.
The EIRP formula can be expressed in decibels-to-milliwatt (dBm)
as follows:&lt;/p&gt;
&lt;!-- EIRP~(dBm) = P_{TX}~(dBm)~+~G_{tx}~(dBi)~+~G_{txbf}~(dB)~-~L_c~(dB) --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="EIRP definition (decibel scale)" src="https://castogio.github.io/images/eirp_explained/dbm_eirp_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;It is common to find in datasheets and regulatory domain documents EIRP values
expressed as a number in dBm followed by &lt;em&gt;e.i.r.p.&lt;/em&gt; (for instance, 20 dBm e.i.r.p.).&lt;/p&gt;
&lt;h2&gt;Why does EIRP matter?&lt;/h2&gt;
&lt;p&gt;Now that the reader has a clearer idea of what EIRP is and how it correlates to
the TX power, we can explore how these two concepts influence our day-to-day. &lt;/p&gt;
&lt;p&gt;ETSI EN 300 328 v2.2 Section 4.3.2.2.3 set the power limit for 
non-Frequency Hopping Spread Spectrum wideband data transmission equipment, such
as 802.11 stations to be less or equal to 20 dBm e.i.r.p. in Europe. Section 5.3.2.2.4 
further specifies that in case a beamforming gain exists, it should be taken
into account for testing the equipment in the ETSI domain.&lt;/p&gt;
&lt;p&gt;The above represents a constraint to the maximum TX power our APs can use.
Once we pick an antenna for our station, we will need to guarantee that the TX
power and the Transmit Beamforming gain (if the latter is used in the transmission)
stay within the specified limit. For instance, if our AP has an internal
antenna (no cable loss) with a 5 dBi and we know we get a 3 dB beamforming gain in our transmission,
then the maximum TX power in Europe must be less or equal to 12 dBm.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Coleman D.D., Westcott D.A. CWNA Certified Wireless Network Administrator
  Study Guide: Exam CWNA-107, Chapters 3 and 4, 5th Edition: Sybex. 2018.&lt;/li&gt;
&lt;li&gt;Haykin S., Moher M. Communication Systems, Chapter 6, 5th Edition: Wiley. 2010.&lt;/li&gt;
&lt;li&gt;Gain (antenna). (2023, March 28). Wikipedia. https://en.wikipedia.org/wiki/Gain_(antenna)&lt;/li&gt;
&lt;li&gt;ETSI, EN. "300 328 V2. 2.2 (2019-07)." Wideband transmission systems (2019).&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry><entry><title>PyBeaconValidator: a project idea</title><link href="https://castogio.github.io/pybeaconvalidator-a-project-idea.html" rel="alternate"></link><published>2023-07-16T12:00:00+01:00</published><updated>2023-07-16T12:00:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-07-16:/pybeaconvalidator-a-project-idea.html</id><summary type="html">&lt;p&gt;I have recently completed a one-week course on advanced Python programming, and
wanted to make something useful with the newly acquired knowledge to simplify
the management of my wireless laboratory.&lt;/p&gt;
&lt;p&gt;I created the first iteration of &lt;strong&gt;PyBeaconValidator&lt;/strong&gt;, a CLI program that can 
parse monitor mode packet captures, select the Beacon …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have recently completed a one-week course on advanced Python programming, and
wanted to make something useful with the newly acquired knowledge to simplify
the management of my wireless laboratory.&lt;/p&gt;
&lt;p&gt;I created the first iteration of &lt;strong&gt;PyBeaconValidator&lt;/strong&gt;, a CLI program that can 
parse monitor mode packet captures, select the Beacon management frames, extract
the content of their Information Elements, and match them with the
configuration specified on the Cisco Meraki Dashboard. The program allows to 
validate if the AP is operating as per its configuration without opening the
Dashboard webpage. This is very helpful in my laboratory when conducting 
experiments as the APs may not fetch new configurations due to the lack of
Internet reachability or otherwise operate incorrectly due to a defect. As a 
side-effect, the program could also confirm if the Beacons are being spoofed.&lt;/p&gt;
&lt;p&gt;The readers can find the GitHub repository at
&lt;a href="https://github.com/castogio/pybeaconvalidator"&gt;this link&lt;/a&gt;. The project is 
at a very early stage, but it already has all the components that will be used
for the "usable" version. The program is released as a &lt;em&gt;Free/Libre Software&lt;/em&gt; 
with a &lt;a href="https://www.gnu.org/licenses/gpl-3.0.en.html"&gt;GNU GPLv3 software license&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Forewords&lt;/h2&gt;
&lt;p&gt;PyBeaconValidator heavily relies on the Cisco Meraki API to access the APs' configuration on the Dashboard. Having access to a working Dashboard,
administrators can enable the API access under &lt;strong&gt;Organization &amp;gt; Settings &amp;gt; Dashboard API access&lt;/strong&gt; 
by selecting the tickbox. After enabling the API, an API
key (i.e. an access token) can be created under &lt;strong&gt;My Profile&lt;/strong&gt;. More information
can be found at &lt;a href="https://documentation.meraki.com/General_Administration/Other_Topics/Cisco_Meraki_Dashboard_API"&gt;this link&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The user needs to have the following dependencies installed from PyPI:
- The &lt;a href="https://github.com/meraki/dashboard-api-python"&gt;dashboard-api-python by Cisco Meraki&lt;/a&gt;, 
  which provides all the current Dashboard API endpoints.
- &lt;a href="https://gitlab.com/mike01/pypacker"&gt;pypacker&lt;/a&gt; a very slim low-level packet
  manipulation library for Python.&lt;/p&gt;
&lt;p&gt;The program requires the use of Python 3.11 (or superior) to work correctly, and
I encourage using a virtual environment, such as &lt;strong&gt;pipenv&lt;/strong&gt; (used for the project)
or &lt;strong&gt;poetry&lt;/strong&gt; for better handling of the dependencies. The install 
procedure looks like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;PATH-TO-PROJECT&amp;gt;/pybeaconvalidator
pipenv&lt;span class="w"&gt; &lt;/span&gt;--python&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;3.11&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;# create pipenv environement&lt;/span&gt;
pipenv&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;meraki
sudo&lt;span class="w"&gt; &lt;/span&gt;apt&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;python3.11-dev
pipenv&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;pypacker&lt;span class="w"&gt; &lt;/span&gt;netifaces
pipenv&lt;span class="w"&gt; &lt;/span&gt;shell&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;# enable pipenv environment&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I am developing the tool on a Trisquel GNU/Linux-libre machine (x86_64).
I intend to test the tool on Apple macOS down the line and, potentially, adapt
it to Microsoft Windows.&lt;/p&gt;
&lt;h2&gt;High-level Program Workflow&lt;/h2&gt;
&lt;p&gt;The idea behind the project is pretty simple, so I wanted the user workflow
to be simple as well.&lt;/p&gt;
&lt;p&gt;The user needs to know their API key as described previously, and it should
specified in the program shell environment as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;MERAKI_DASHBOARD_API_KEY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;your-api-key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PyBeaconValidator also assumes the user captured a monitor mode packet capture to be
analysed in &lt;em&gt;.pcap&lt;/em&gt; format, for instance, taken on a MacBook using the wireless
sniffer tool. I decided not to integrate the capture function into the program as 
it would increase the complexity, and often the wireless network card of the
host machine would not be able to take monitor mode pcaps anyway.&lt;/p&gt;
&lt;p&gt;Once the above is cleared, PyBeaconValidator executes the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The program reads the Cisco Meraki Network ID from the program arguments; the same
   is done to the path to the capture file.&lt;/li&gt;
&lt;li&gt;The program retrieves the details of the APs in the wireless network, such as the name,
   serial number, model, MAC address, and tags.&lt;/li&gt;
&lt;li&gt;The program retrieves the BSSID data for each AP. The information will be matched with
   the Transmitter Address (TA) of the Beacons so that the program can identify
   which unit is broadcasting the frame.&lt;/li&gt;
&lt;li&gt;The program retrieves the configuration for all the SSIDs in the network. The Cisco
   Meraki Dashboard allows configuring up to 15 SSIDs at the time of this post.&lt;/li&gt;
&lt;li&gt;The program parses the packet capture, filtering the Beacon management frames only and
   extracting their information, such as the TA, the channel (from the RadioTap 
   header), the SSID name, and the Supported Rates Information Element (IE).
   I extracted only the IEs I need at the moment, but more might be added in the
   future; feel free to contribute on GitHub.&lt;/li&gt;
&lt;li&gt;The program creates a list of pairs for each network configuration containing
   the &lt;em&gt;expected&lt;/em&gt; value as configured on Dashboard and the &lt;em&gt;actual&lt;/em&gt; value
   advertised in the beacon frames in the packet capture.&lt;/li&gt;
&lt;li&gt;If there is a mismatch between the expected and the actual value,
   the program alerts the user with a warning on the screen.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The sequence diagram below shows the high-level workflow described previously:&lt;/p&gt;
&lt;!-- 
@startuml PyBeaconValidator
actor User as u #red
participant PyBeaconValidator as pr 
participant "Cisco Meraki Cloud" as mc #LightGreen
database "FileSystem" as fs

u-&gt;pr: network_id, pcap_path
pr-&gt;mc: get_all_aps(network_id)
pr&lt;--mc: list[access_point]
loop for each access_point
    pr-&gt;mc: get_all_bssids(access_point)
    pr&lt;--mc: list[bssid]
end
pr-&gt;mc: get_all_ssid_config(network_id)
pr&lt;--mc: list[ssid_config]
pr-&gt;fs: read_file(pcap_path)
pr&lt;--fs: pcap_file
pr-&gt;pr: parse pcap_file
pr-&gt;pr: compare(expected, actual)
u&lt;--pr: show mismatches
@enduml
--&gt;

&lt;p&gt;&lt;img alt="PyBeaconValidator sequence diagram" src="https://castogio.github.io/images/pybeaconvalidator_presentation/pybeaconvalidator_seq_diagram.png"&gt;&lt;/p&gt;
&lt;h2&gt;Exemple of execution&lt;/h2&gt;
&lt;p&gt;The User Interface of PyBeaconValidator in this first iteration is still fairly
minimal; however, it allows to execute test runs for debugging quite easily
with minimal user interaction as the commands can be issued automatically by
programming editors such as VSCodium or Vim. You can run the program from
the shell as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="PyBeaconValidator command" src="https://castogio.github.io/images/pybeaconvalidator_presentation/running_program.png"&gt;&lt;/p&gt;
&lt;p&gt;In the current implementation, the output is silent if there is no mismatch. I created an
"artificial" mismatch by blocking the traffic from the APs to the Cisco Meraki
Cloud using a firewall and then changing the &lt;em&gt;minimum&lt;/em&gt; (basic) bitrate configuration.
As shown in the screenshot below, the program displays a &lt;em&gt;WARNING&lt;/em&gt; log for the
mismatch containing the timestamp (ts) of the beacon in the file, the Serial
Number (sn) of the AP in question, the BSSID and the expected vs. actual (seen)
values for the bitrate:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Minimum bitrate mismatch warning" src="https://castogio.github.io/images/pybeaconvalidator_presentation/output.png"&gt;&lt;/p&gt;
&lt;h2&gt;Frame processing insights&lt;/h2&gt;
&lt;p&gt;I selected &lt;em&gt;pypacker&lt;/em&gt; as the capture parser, among other alternatives, as it seems 
to be the fastest library available at the moment. I gave a go to
&lt;a href="https://github.com/KimiNewt/pyshark"&gt;pyshark&lt;/a&gt;, which is a Python wrapper for
&lt;a href="https://man.archlinux.org/man/tshark.1"&gt;tshark&lt;/a&gt;, but it was unbearably slow
even for small captures.&lt;/p&gt;
&lt;p&gt;The following code snippet shows how the beacons are extracted from the capture 
file in the program when using Pypacker:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypacker&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ppcap&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pypacker.layer12&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;radiotap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ieee80211&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;beacons&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;ppcap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Reader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capture_file_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;capture_reader&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ts_ns&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;capture_reader&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

        &lt;span class="c1"&gt;# all the frames in the .pcap file are incapsulated into Radiotab&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radiotap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Radiotap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="c1"&gt;# decapsulate the Radiotap, IEEE802.11 header and the Beacon payload&lt;/span&gt;
        &lt;span class="n"&gt;radiotap_header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dot11_header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;beacon_payload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                                              &lt;span class="n"&gt;ieee80211&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IEEE80211&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                                              &lt;span class="n"&gt;ieee80211&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IEEE80211&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Beacon&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;# the frame is not a Beacon, the payload is None&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;beacon_payload&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt; &lt;span class="c1"&gt;# skip frame and go to the next one&lt;/span&gt;

        &lt;span class="c1"&gt;# extract all required the fields from the Beacon frame&lt;/span&gt;
        &lt;span class="n"&gt;beacon_frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_process_pypacker_frame_headers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radiotap_header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                                       &lt;span class="n"&gt;dot11_header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                                                       &lt;span class="n"&gt;beacon_header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ts_ns&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;beacons&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;beacon_frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Despite the conceptual simplicity of Pypacker's programming interface, it
offloads much of the responsibility of parsing the raw byte content of the IEs
to the programmer. This behaviour gives more freedom to the programmer, but
it increases the difficulty in analysing the most common IE, such as the
Supported Rates. As you can see in the snippet below, the computation required on
the byte octets in the IE (each one refers to one of the supported rates):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;supported_rates_ie&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;beacon_header&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;supported_rates_ie&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body_bytes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="c1"&gt;# check if the bitrate value refers to a BASIC bitrate by checking the&lt;/span&gt;
    &lt;span class="c1"&gt;# first bit of the octect e.g. 1000 0000 --&amp;gt; Basic Bitrate&lt;/span&gt;
    &lt;span class="n"&gt;is_mandatory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# compute bitrate in Mbps by multiplying octect&lt;/span&gt;
    &lt;span class="c1"&gt;# remove if 1st bit in case of mandatory bitrate&lt;/span&gt;
    &lt;span class="c1"&gt;# bitrate = (octect * 500 kbps) // 1000&lt;/span&gt;
    &lt;span class="n"&gt;bitrate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;is_mandatory&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Frame processing insights&lt;/h2&gt;
&lt;p&gt;This project is still at a very early stage, and I plan to add
more and more features over time. It is an excellent opportunity to get
hands-on experience with frame processing and learn more about network
automation in Python. PyBeaconValidator is freely available on GitHub, so the
readers can download the source code, study it, modify and redistribute their
copies.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“Meraki Dashboard API Python Library”, 
   Cisco Meraki, GitHub, https://github.com/meraki/dashboard-api-python. 
   Accessed 16 July 2023.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“pypacker”, Michael Stahn, GitLab, https://gitlab.com/mike01/pypacker. 
   Accessed 16 July 2023.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry><entry><title>R&amp;D sneak peek: Multi-AP Coordinated Spatial Reuse for Wi-Fi 8</title><link href="https://castogio.github.io/rd-sneak-peek-multi-ap-coordinated-spatial-reuse-for-wi-fi-8.html" rel="alternate"></link><published>2023-06-14T18:00:00+01:00</published><updated>2023-06-14T18:00:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-06-14:/rd-sneak-peek-multi-ap-coordinated-spatial-reuse-for-wi-fi-8.html</id><summary type="html">&lt;p&gt;In this post, I would like to describe an exciting take on Multi-AP 
Coordination (MAPC) leveraging Spatial Reuse (SR). AP coordination has groups of
APs communicate with each other to minimise collisions while transmitting at the
same time and on the same frequency channel. I recently came across a scientific …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this post, I would like to describe an exciting take on Multi-AP 
Coordination (MAPC) leveraging Spatial Reuse (SR). AP coordination has groups of
APs communicate with each other to minimise collisions while transmitting at the
same time and on the same frequency channel. I recently came across a scientific
article by David Nunez et al. in [1], which I believe is worth understanding as it
proposes an algorithm to identify coordinated AP groups and simultaneously schedule
transmissions of their buffered frames.&lt;/p&gt;
&lt;h2&gt;What is Spatial Reuse?&lt;/h2&gt;
&lt;p&gt;Spatial Reuse is not a new concept in wireless communications. If a transmitter
is “distant” enough from other transmitters on the same channel, it can consider
them background noise when communicating with its intended clients. Think
about yourself speaking in English to an audience in a large garden. Other
people can do the same 20 yards away from yours and each other’s groups if
everyone agrees to be well-behaved. Communication is possible because the sound is
affected by Path Loss; the same can be applied to 802.11 wireless communication
when considering a model such as the TGax model for Enterprise Scenarios [2]
which considers the distance between the transmitter and receiver, the
frequency used and the number of walls. The mathematical details are not
interesting for understanding the concept, but you may appreciate how being in a
harsh RF environment causing strong attenuation can reduce the reuse distance.
The picture below shows a client station called STA, being able to hear 
AP&lt;sub&gt;4&lt;/sub&gt; and AP&lt;sub&gt;5&lt;/sub&gt; on the same channel used by AP&lt;sub&gt;2&lt;/sub&gt;
to which it is connected.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Spatial Reuse cells and co-channel interference" src="https://castogio.github.io/images/mapc_sr/spatial_reuse_cells.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;AP4 and AP5 are interferers and contribute to the effect of background noise in
the communications from AP&lt;sub&gt;2&lt;/sub&gt;, potentially preventing STA from
receiving readable signals. The effect of background noise and interference over
the useful signal is described by the following formula for the Signal to
Interference plus Noise Ratio (SINR), as seen on the client STA for the
transmission from AP&lt;sub&gt;2&lt;/sub&gt;:&lt;/p&gt;
&lt;!-- SINR_{STA}^{2} = \frac{P_2}{N + \sum_{j \neq 2} P_{j}} --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="SINR formula" src="https://castogio.github.io/images/mapc_sr/sinr_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;where P&lt;sub&gt;2&lt;/sub&gt; and P&lt;sub&gt;j&lt;/sub&gt; are the received power from AP&lt;sub&gt;2&lt;/sub&gt;
and the other &lt;em&gt;j&lt;/em&gt; APs as seen from STA respectively, and N is the noise power. 
We cannot alter the &lt;em&gt;N&lt;/em&gt; value as it is due to external factors in the
environment beyond our control (e.g. the APs of a neighbouring office),
so we should keep the sum of the P&lt;sub&gt;j&lt;/sub&gt; as low as possible. 
The obvious course of action is not to have APs with higher interference power
transmit at the same time as AP&lt;sub&gt;2&lt;/sub&gt;.
We face a new problem: how do we select the group of APs that can transmit at
the same time as AP&lt;sub&gt;2&lt;/sub&gt;?&lt;/p&gt;
&lt;h2&gt;Detecting Coordinated Groups for SR&lt;/h2&gt;
&lt;p&gt;The paper defines a “&lt;em&gt;Sharing AP&lt;/em&gt;” as the coordinator for a group of
“&lt;em&gt;Shared APs.&lt;/em&gt;” They also assume that all the APs are within the coverage area
of the Sharing AP, which can access the medium and send a 
Multi-AP Request-To-Send (MAP-RST) to reserve the channel. In case of no
collisions on their side, the Shared APs reply with a MAP Clear-To-Send
(MAP-CTS), guaranteeing that the clients in the service area will stay silent
for the rest of the Transmit Opportunity Sharing (TXOP-sharing) transmission.
Once the Sharing AP can access the channel, the shared TXOP is divided into one
or more coordinated temporal slots. It also signals which APs should transmit
during each slot with a MAP Trigger Frame (MAP-TF).
Effectively the authors leverage &lt;em&gt;Time Division Multiple Access&lt;/em&gt; (TDMA)
as they have the Sharing AP reserving the channel, and they enhance it with SR
by selecting only transmitters that interfere the least.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="TXOP-sharing period" src="https://castogio.github.io/images/mapc_sr/TXOP_sharing_breakdown.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;To create groups of APs that can transmit together, the authors define a Central
Controller (CC) that knows all the received powers P&lt;sub&gt;j&lt;/sub&gt; as seen from
the STA and can compute the SIND for each AP. They assume that the RF channel
is always symmetric so that the power the client receives in transmissions from
the AP (downlink) is the same as the AP receives from the client on the way back
(uplink). In light of this, all the APs in the same coordinated group of size
M must guarantee that their SINR for each of their connected client STAs is
above an m threshold so that:&lt;/p&gt;
&lt;!-- \min_{j=1...M}SINR_{STA}^{j} \geqslant m --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="SINR formula" src="https://castogio.github.io/images/mapc_sr/min_sinr_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The APs within the same group of K units are identified using a 
&lt;a href="https://en.wikipedia.org/wiki/Greedy_algorithm"&gt;“greedy” strategy&lt;/a&gt; called the 
“&lt;em&gt;At-most-K&lt;/em&gt;” algorithm. An AP is selected as a reference, and on each iteration
a new AP is added if the formula described above holds and the SINR is still
high enough for all the client STAs connected to APs already in the group.&lt;/p&gt;
&lt;h2&gt;Traffic Scheduling Algorithms&lt;/h2&gt;
&lt;p&gt;The operation can be repeated using different reference APs to find multiple
groups of “compatible” APs. APs in better
positions (or trivially far enough) may belong to various groups.
Once the groups are identified, the CC must select what groups should transmit.
The paper proposes four strategies based on the number of packets buffered in
the APs of the group:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;NumPkSingle&lt;/em&gt;: the CC selects the groups containing the AP with the highest 
   number of buffered packets, and then picks the single group with the highest 
   number of buffered packets across all the APs in the group.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;NumPkGroup&lt;/em&gt;: the CC selects the group with the most packets.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OldOkSingle&lt;/em&gt;: the CC selects the groups containing the AP with the oldest
   buffered packet, and then picks the single group with the highest aggregate
   group delay as a sum of the waiting times of the oldest buffered packets
   across all the APs in the group.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OldPkGroup&lt;/em&gt;: the CC selects the group with the highest aggregate group delay.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The algorithms prevent starvation between groups when using NumPkGroup and 
OldPkGroup by dividing the aggregated value by the number of APs in the groups;
this is particularly important whenever there are groups with just a few APs and
others with a large number of units. The simulation results presented in the
paper show that NumPkSingle and OldOkSingle (&lt;em&gt;per-AP selection&lt;/em&gt;) outperform the
other strategies (&lt;em&gt;per-Group selection&lt;/em&gt;) when the TXOP-sharing transmissions are
scheduled every 5 milliseconds, and the SINR threshold is 20 dB, high enough to
guarantee the use of a high Modulation and Coding Scheme (MCS) in the simulation
using 9 APs transmitting on the same channel.&lt;/p&gt;
&lt;h2&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;MAPC is still a hot topic for research, and commercially-available APs will
probably use some still-unknown solution. I hope this blog post picked the
readers’ interest in what is coming in the future iterations of IEEE 802.11,
probably in 8/10 years.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Nunez, David, Malcom Smith, and Boris Bellalta. 
"&lt;em&gt;Multi-AP Coordinated Spatial Reuse for Wi-Fi 8: Group Creation and Scheduling.&lt;/em&gt;"
arXiv preprint arXiv:2305.04846 (2023).&lt;/li&gt;
&lt;li&gt;Merlin, Simone, et al. "&lt;em&gt;TGax simulation scenarios.&lt;/em&gt;" IEEE802 (2015): 11-14.&lt;/li&gt;
&lt;/ol&gt;</content><category term="802.11"></category></entry><entry><title>Decoding AireOS monitor mode captures on Wireshark</title><link href="https://castogio.github.io/decoding-aireos-monitor-mode-captures-on-wireshark.html" rel="alternate"></link><published>2023-05-28T12:00:00+01:00</published><updated>2023-05-28T12:00:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-05-28:/decoding-aireos-monitor-mode-captures-on-wireshark.html</id><summary type="html">&lt;p&gt;I am writing this blog post primarily for my future reference, and while it 
will be nice and short, I hope it will save a few minutes for other
troubleshooters on the web.&lt;/p&gt;
&lt;p&gt;I recently had to analyse the over-the-air traffic for a customer of mine, and
they used a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I am writing this blog post primarily for my future reference, and while it 
will be nice and short, I hope it will save a few minutes for other
troubleshooters on the web.&lt;/p&gt;
&lt;p&gt;I recently had to analyse the over-the-air traffic for a customer of mine, and
they used a Cisco AireOS Lightweight AP (LAP) for their monitor mode captures.
Captures taken either on specialised sniffers or repurposed clients (e.g.
MacBooks or Raspberry Pi boxes with Kali Linux) do not require any special 
handling when opened with Wireshark, and you would see the list of frames
immediately.&lt;/p&gt;
&lt;p&gt;On the other hand, AireOS went down a different path, and its captures require 
specialised decoding. Wireshark interprets the wireless frames as
encapsulated within UDP segments to port 5555. The following screenshot shows what 
you would be able to see in the packet analyser:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="AireOS capture in Wireshark" src="https://castogio.github.io/images/aireos_encoded_pcap/not_decoded_aireos.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;As for many things in radio communications, the packets in question can be 
&lt;strong&gt;decoded&lt;/strong&gt; using an appropriate interpretation method. Wireshark has a built-in
tool in the topbar under &lt;strong&gt;Analyze &amp;gt; Decode As...&lt;/strong&gt; as shown in
the screenshot below.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="AireOS capture in Wireshark" src="https://castogio.github.io/images/aireos_encoded_pcap/adding_new_decode_rule.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Click the + (plus) button to add a new decode rule to the list above.
You will need to insert the following decoding parameters:
- Field: UDP port
- Value: 5555
- Type: Integer, base 10
- Default: SIGCOMP
- Current: PEEKREMOTE&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="AireOS capture in Wireshark" src="https://castogio.github.io/images/aireos_encoded_pcap/decode_rule.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;After making sure that the values inserted are correct, click the "OK" button
and the list of frames in Wireshark will immediately change to reflect
the actual content of the monitor mode capture, as shown below.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="AireOS capture in Wireshark" src="https://castogio.github.io/images/aireos_encoded_pcap/decoded_aireos.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;“Analyze and Troubleshoot 802.11 Wireless Sniffing.” 
   Cisco Systems, Nov. 2022, https://bit.ly/43c7lAT. Accessed 28 May 2023.&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry><entry><title>Channel Switch Announcements explained</title><link href="https://castogio.github.io/channel-switch-announcements-explained.html" rel="alternate"></link><published>2023-05-08T00:01:00+01:00</published><updated>2023-05-08T00:01:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-05-08:/channel-switch-announcements-explained.html</id><summary type="html">&lt;p&gt;In this article, I would like to describe what I believe is an interesting 
mechanic of dot11 wireless networks called &lt;em&gt;Channel Switch Announcement&lt;/em&gt; (CSA). 
This is often overlooked as it usually works flawlessly, but it is
almost ubiquitous in today's deployments because admins
use automatic Resource Radio Management (RRM), which …&lt;/p&gt;</summary><content type="html">&lt;p&gt;In this article, I would like to describe what I believe is an interesting 
mechanic of dot11 wireless networks called &lt;em&gt;Channel Switch Announcement&lt;/em&gt; (CSA). 
This is often overlooked as it usually works flawlessly, but it is
almost ubiquitous in today's deployments because admins
use automatic Resource Radio Management (RRM), which may prompt for 
(frequent) channel changes on the Access Points as they adapt to the surrounding
RF environment. CSAs are also used whenever a Dynamic Frequency Selection (DFS)
occurs in the 5 GHz band, and the AP must move to a non-radar channel.&lt;/p&gt;
&lt;p&gt;The primary goal of CSAs is to allow the AP to change its channel while keeping
the clients associated. Of course, the clients should follow the AP along with 
the change and start transmitting on the new channel, but they may decide
to disassociate.&lt;/p&gt;
&lt;p&gt;We will explore together the CSA procedures and the Information Element (IE) 
formats as defined in the IEEE802.11-2020 standard, and confirm the behaviours
in two Case Studies for DFS-triggered and RRM-triggered channel switches.
Please note that this blog post specifically describes the case of APs in a 
Basic Service Set (BSS).&lt;/p&gt;
&lt;h2&gt;Announcement procedure&lt;/h2&gt;
&lt;p&gt;First, we need to clarify where the AP puts Channel Switch Announcements. 
These CSAs are carried by the &lt;em&gt;CSA Information Element&lt;/em&gt; (IE) and the &lt;em&gt;Extended&lt;/em&gt;
&lt;em&gt;CSA IE&lt;/em&gt; in the following types of frames right before the change is operated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Beacon Management Frames&lt;/strong&gt; (Wireshark filter: wlan.fc.type_subtype == 8).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Probe Responses&lt;/strong&gt; (Wireshark filter: wlan.fc.type_subtype == 5).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spectrum Management Action Frames&lt;/strong&gt; (Wireshark filter: wlan.fc.type_subtype == 13).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see an exhibit from Wireshark showing a sequence of Beacon frames and
an Action frame before a channel switch from Ch 112 to Ch 48.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="CSAs frames in Wireshark" src="https://castogio.github.io/images/csa_explained/wireshark_list_frames.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;All these frames are &lt;em&gt;broadcast&lt;/em&gt;, and they carry information regarding what the
&lt;em&gt;new channel&lt;/em&gt; will be, and they state how much time is left before the switch, 
expressed as a multiplicative factor of the 
TBTT (Target Beacon Transmission Time). 
I made sure the picture shows them  in a human-friendly format by re-naming the 
columns, but we will do a deep dive into the details of the IE in the following sections.&lt;/p&gt;
&lt;h2&gt;CSA Information Element format&lt;/h2&gt;
&lt;p&gt;When it comes to Information Elements, the best place where to find clear
information is the standard paper itself, so this section takes heavily from
&lt;strong&gt;IEEE 802.11-2020 Section 9.4.2.18&lt;/strong&gt;. The following figure shows the Channel
Switch Announcement IE format as defined in the standard to "advertise when [an 
AP] is changing to a new channel and the channel number of the new channel."
 This IE was introduced in the IEEE 802.11h amendment.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="CSA element format" src="https://castogio.github.io/images/csa_explained/csa_ie_format.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The following fields are defined:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;Element ID&lt;/em&gt; (1 byte) always assumes the value 37.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;Channel Switch Mode&lt;/em&gt; Field (1 byte) can assume the value &lt;em&gt;0&lt;/em&gt; when the 
  client stations and the AP can continue exchanging frames before the
  channel switch happens. If the value is &lt;em&gt;1&lt;/em&gt;, no more frames should be
  exchanged before the switch.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;New Channel Number&lt;/em&gt; field (1 byte) is the channel that the AP will
  use after the switch (you could call it the "new channel").&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;Channel Switch Count&lt;/em&gt; field (1 byte) is tricky as it states how much
  time will elapse before the channel change. It is expressed in multiples 
  of the TBTT, which is the target amount of time between a Beacon Frame and the 
  following one for the same BSS (assuming the medium is available). A TBTT is 
  composed of 100 Time Units (TUs), which in turn is 1024 
  microseconds. The Channel Switch Count value &lt;em&gt;1&lt;/em&gt; means that the AP will
  broadcast the next Beacon frame and continue operating in the new channel.
  Value &lt;em&gt;0&lt;/em&gt; indicates that the actual switch will happen &lt;em&gt;at any time&lt;/em&gt; after the 
  current frame is broadcasted (i.e. the clients may want to switch immediately
  to be prepared).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Extended CSA Information Element format&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IEEE 802.11-2020 Section 9.4.2.52&lt;/strong&gt; defines the Extended Channel Switch
Announcement IE (E-CSA IE), which specifies if the "BSS is changing to a new 
channel in the same or a new operating class." This IE was introduced in 
the IEEE 802.11y amendment to replace the CSA IE. The latter is still 
broadcasted for backward compatibility.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Extended CSA element format" src="https://castogio.github.io/images/csa_explained/extended_csa_ie.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;This IE carries almost the same information as the CSA IE, so we will focus on 
a subset of them, which are particularly interesting and justify the existence 
of the Extended CSA element:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;Element ID&lt;/em&gt; (1 byte) is 37.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;New Operating Class&lt;/em&gt; (1 byte) field specifies the new operating class
  after the channel switch happens. The values for classes are defined in 
  "Annex E" of the standard, they depend on the Regulatory Domain as specified 
  in the Country Element (Section 9.4.2.8), and they indicate the frequency of 
  the channel, the channel centre frequency, the maximum channel width, and 
  other behavioural constraints.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Case Study: DFS-triggered channel changes&lt;/h2&gt;
&lt;p&gt;The standard is quite dry, so I recreated the conditions of a channel switch by 
simulating a DFS event in my lab network to observe what values populated the 
fields we described in the previous sections.&lt;/p&gt;
&lt;p&gt;My AP was operating on channel 112, which falls in the 
The Unlicensed National Information Infrastructure 2 Extended (U-NII-2e)
range might be affected by DFS events caused by radars or any
other RF radiator mimicking radar. If an event is detected, the AP must inform
the clients that they have to stop transmitting and move to a different channel,
usually referred to as a "mute" or "fallback" channel. The AP
and the clients have 10 seconds to leave the DFS channel.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Captured CSA IE values for DFS" src="https://castogio.github.io/images/csa_explained/channel_switch_announcement_information_element.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;As you can see in the figure above, the CSA IE states that the new channel is 
48 (a non-DFS channel in the U-NII-1 range), the switch will happen in 5 TBTTs,
and the &lt;em&gt;clients should not transmit any more frames over the current channel&lt;/em&gt;.
The latter command is unsurprising, and it perfectly aligns with the 
DFS requirement.&lt;/p&gt;
&lt;p&gt;The AP can send one or more CSA frames in the form of Beacons, Probe Responses 
and Action Frames to make sure that all its clients move and keep 
their association status.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="CapturedExtended CSA IE for DFS" src="https://castogio.github.io/images/csa_explained/extended_channel_switch_announcement_information_element.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The E-CSA field is contained in the same frames, and it carries similar 
information with the addition of the "New Operating Class" equal to 0x01 
(hexadecimal). In Europe, where I live, class 1 means that the new channel 
belongs to a group composed of Channels 36, 40, 44, and 48 (i.e. U-NII-1), the 
starting frequency for the group is 5 GHz, their channel spacing is 20 MHz, and
there are no additional behaviour limits (refer to Table E-2 from the standard).&lt;/p&gt;
&lt;h2&gt;Case Study: RRM-triggered channel changes&lt;/h2&gt;
&lt;p&gt;Channel changes due to automatic RRM are another fascinating case study,
probably more relevant than the DFS one, as RRM can kick in very frequently 
when the RF environment is particularly harsh (e.g. high channel utilisation).&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Captured CSA for RRM Channel Change" src="https://castogio.github.io/images/csa_explained/csa_channel_change.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The figure above shows the CSA and E-CSA IEs when the channel is about to 
switch to 161. The new operating class is 0x11 (hex for 17), which in Europe 
refers to the channel set containing 149, 153, 157, 161, 165, and 169 (also
known as U-NII-3).
Furthermore, note that the Channel Switch Mode is set to 0, so the 
clients and the AP may keep exchanging frames until the channel switch, hence 
virtually nullifying (or minimising as much as possible) any service 
interruptions during RRM channel switches.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IEEE 802.11-2020: Wireless LAN Medium Access Control (MAC) and Physical Layer 
  (PHY) Specifications (2020 revision), IEEE-SA, 2021&lt;/li&gt;
&lt;li&gt;Coleman, David D., and David A. Westcott. CWNA Certified Wireless Network 
  Administrator Study Guide: Exam CWNA-107. John Wiley &amp;amp; Sons, 2018.&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry><entry><title>About Me</title><link href="https://castogio.github.io/about-me.html" rel="alternate"></link><published>2023-05-01T22:11:00+01:00</published><updated>2023-05-01T22:11:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-05-01:/about-me.html</id><summary type="html">&lt;p&gt;My name is Gioacchino Castorio, but people call me Jack or Kino.
I am a professional wireless network troubleshooter and a certified amateur 
radio operator in the UK; my callsign is MI0YTF.&lt;/p&gt;
&lt;p&gt;&lt;img alt="my picture" src="https://castogio.github.io/images/personal_intro/profile_pic.png"&gt;&lt;/p&gt;
&lt;p&gt;I spend most of my time working out, going for walks, reading technical books, 
or writing my own …&lt;/p&gt;</summary><content type="html">&lt;p&gt;My name is Gioacchino Castorio, but people call me Jack or Kino.
I am a professional wireless network troubleshooter and a certified amateur 
radio operator in the UK; my callsign is MI0YTF.&lt;/p&gt;
&lt;p&gt;&lt;img alt="my picture" src="https://castogio.github.io/images/personal_intro/profile_pic.png"&gt;&lt;/p&gt;
&lt;p&gt;I spend most of my time working out, going for walks, reading technical books, 
or writing my own video games and utility programs in Python.&lt;/p&gt;
&lt;p&gt;I created this blog to share tips and tricks when troubleshooting, keeping track
of what I learnt, exploring research topics and experimenting with
network programmability.&lt;/p&gt;
&lt;h2&gt;Contacts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;My LinkedIn Profile: https://uk.linkedin.com/in/gioacchinocastorio&lt;/li&gt;
&lt;li&gt;GitHub account: https://github.com/castogio&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;My (current) certifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Certified Wireless Analysis Professional (CWAP), CWNP&lt;/li&gt;
&lt;li&gt;Certified Wireless Security Professional (CWSP), CWNP&lt;/li&gt;
&lt;li&gt;Certified Wireless Design Professional (CWDA), CWNP&lt;/li&gt;
&lt;li&gt;Certified Wireless Network Administrator (CWNA), CWNP&lt;/li&gt;
&lt;li&gt;Certified Wireless IoT Solutions Administrator (CWISA), CWNP&lt;/li&gt;
&lt;li&gt;Cisco Certified Network Professional (CCNP), Cisco&lt;/li&gt;
&lt;li&gt;Cisco Certified Specialist - Enterprise Design (ENSLD), Cisco&lt;/li&gt;
&lt;li&gt;Cisco DevNet Associate (DEVASC), Cisco&lt;/li&gt;
&lt;li&gt;Certified Professional in Python Programming 1 (PCPP1), Python Institute&lt;/li&gt;
&lt;li&gt;Amateur Full Radio Licence, Ofcom&lt;/li&gt;
&lt;/ul&gt;</content><category term="About Me"></category></entry><entry><title>Introduction to RX-SOP Configuration</title><link href="https://castogio.github.io/introduction-to-rx-sop-configuration.html" rel="alternate"></link><published>2023-05-01T12:00:00+01:00</published><updated>2023-05-01T12:00:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-05-01:/introduction-to-rx-sop-configuration.html</id><summary type="html">&lt;p&gt;The Cisco Receiver Start of Packet Detection Threshold (RX-SOP) is 
a feature available on a multitude of enterprise access points, but experience 
taught me junior wireless engineers often misunderstand it.&lt;/p&gt;
&lt;p&gt;In a sentence, the RX-SOP configuration declares the Wi-Fi power required for an 
access point to pick up signals, demodulation …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The Cisco Receiver Start of Packet Detection Threshold (RX-SOP) is 
a feature available on a multitude of enterprise access points, but experience 
taught me junior wireless engineers often misunderstand it.&lt;/p&gt;
&lt;p&gt;In a sentence, the RX-SOP configuration declares the Wi-Fi power required for an 
access point to pick up signals, demodulation and then start decoding the 
physical layer protocol data unit (PPDU). 
This definition begs the question: why is such a feature required?
Having a clear picture of how signal decay 
over distance is necessary to understand the implications of RX-SOP.
​&lt;/p&gt;
&lt;h2&gt;RF propagation refresher&lt;/h2&gt;
&lt;p&gt;​
We call an "isotropic radiator" an intentional radiator (IR) with no spatial 
dimensions (i.e. a dot) in the infinite void, emitting a wave
signal of amplitude P(tx) in all directions. This entity is, of course, ideal,
and it cannot be implemented in real life, but it will help us describe
the behaviour of radiation moving through space. &lt;/p&gt;
&lt;!-- The power emitted is maximum at the IR and equal to P(tx).  --&gt;
&lt;p&gt;A receiver at a distance &lt;em&gt;d&lt;/em&gt; for the IR would see a different power level 
&lt;em&gt;strictly less&lt;/em&gt; than P(tx), as the transmitted amount spreads 
to all directions; we can name the received power P(rx).
In the case of an isotropic IR, we can easily compute P(rx)
as the power spreads over a spherical wavefront.
The &lt;em&gt;power density I&lt;/em&gt; at a distance &lt;em&gt;d&lt;/em&gt; on a punctiform section of the sphere
is defined as follows:
​&lt;/p&gt;
&lt;!-- I = \frac{P_{tx}}{2\pi d^{2}} --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="transmit power density formula" src="https://castogio.github.io/images/rxsop_intro/power_density_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;In other words, the value "I" represents how the transmitted power distributes 
in a point at a distance &lt;em&gt;d&lt;/em&gt; from the IR. It also lets us compute how much power 
P(rx) can be captured by a punctiform section of the receiving antenna. &lt;/p&gt;
&lt;p&gt;Multiplying &lt;em&gt;I&lt;/em&gt; by the &lt;em&gt;effective area&lt;/em&gt; of the antenna will
give us the total received power. The effective area depends on the directivity 
of the receiving antenna in general. However, when the receiver is far away from 
the transmitter (at least two or three times the wavelength &lt;em&gt;lambda&lt;/em&gt;), it can be 
&lt;a href="https://bit.ly/40WJMdj"&gt;proven&lt;/a&gt; that:
​&lt;/p&gt;
&lt;!-- P_{rx} = I A_{eff} = \frac{P_{tx}}{2\pi d^2}A_{eff} = 
    P_{tx} (\frac{\lambda}{2 \pi d})^2  = FSPL(d) * P_{tx}
--&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="received power formula" src="https://castogio.github.io/images/rxsop_intro/received_power_formula.png"&gt;
&lt;/center&gt;
​
As you can see from the above, the distance &lt;em&gt;d&lt;/em&gt; contributes significantly to
the power loss in ideal conditions. We call this effect the Free 
Space Path Loss (FSPL). At a distance of 1 m from the IR, regardless of the
transmitted power, P(rx) is approximately 40%
less than the transmitted power. The figure below shows the decay of the 
received power for varying values of the distance &lt;em&gt;d&lt;/em&gt; when the transmit power 
P(tx) = 30 dBm and the lambda = 6 cm (frequency = 5 GHz) are set:&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="rx power delay FSPL" src="https://castogio.github.io/images/rxsop_intro/fspl_grapth.png"&gt;
&lt;/center&gt;
​
What we described superimposes to other detrimental effects, 
(such as material absorption) which are effectively multiplicative factors in 
the formula for P(rx) and it makes the curve decay faster.&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2&gt;RX-SOP operations&lt;/h2&gt;
&lt;p&gt;​
Having a clearer picture of the harshness of the RF environment, the receiver 
needs to detect between actual signals, which intensity may be comparable to a 
whisper in a noisy environment. This is when RX-SOP comes into play.&lt;/p&gt;
&lt;p&gt;There is a power level called "sensitivity," which is the signal strength 
(expressed in dBm) of the weakest signal that the AP can distinguish from 
the background noise and process successfully.
RX-SOP does not alter the sensitivity of your access point. On the other hand, 
changing the RX-SOP level forces the AP to &lt;em&gt;actively ignore&lt;/em&gt; signals below a 
specific power in dBm. For instance, Cisco Meraki APs use -95 dBm by default when
enabled on the Dashboard.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="meraki rx-sop default" src="https://castogio.github.io/images/rxsop_intro/meraki_rx_sop_default.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The described concept may sound familiar to those of you who are amateur radio
operators, as this is a form of 
"&lt;a href="https://en.wikipedia.org/wiki/Squelch"&gt;carrier squelch&lt;/a&gt;", 
i.e. suppressing the receiver output if the input signal is not strong enough. 
You can see the effects of RX-SOP muting when the level is set to -70 dBm:
​&lt;/p&gt;
&lt;!-- SEQUENCE DIAGRAM
    @startuml
    Client -[#green]&gt; AP: frame received at -60 dBm (&gt; -70 dBm)
    AP -[#green]&gt; AP: PROCESSED
    Client -[#green]&gt; AP: signal -50 dBm (&gt; -70 dBm)
    AP -[#green]&gt; AP: PROCESSED
    Client -[#red]&gt; AP: signal -75 dBm (&lt; -70 dBm)
    Client -[#red]&gt; AP: signal -71 dBm (&lt; -70 dBm)
    Client -[#red]&gt; AP: signal -80 dBm (&lt; -70 dBm)
    @enduml
--&gt;

&lt;p&gt;&lt;center&gt;
    &lt;img alt="RX-SOP operatiomns" src="https://castogio.github.io/images/rxsop_intro/rx_sop_operation.png"&gt;
&lt;/center&gt;
​
Quoting from the Cisco documentation, this feature is "ideal for high-density environments [...]
where there are a large number of client devices connected per AP [... where
...] the smaller the cell size, the better."
​
The benefit might come from the fact that the AP will not reset its 
Network Allocation Vector (NAV) timer when receiving a signal below the 
threshold so that it can start transmitting relatively more frequently.
​
I saw this configuration altered in the wild by inexperienced administrators and 
troubleshooters without properly validating its effect on the environment,
primarily to address the issue of sticky clients. The latter is not advisable:
the RX-SOP is a receive-only configuration, and it applies &lt;strong&gt;only&lt;/strong&gt; to the AP
side, while the client will continue receiving transmissions from the AP
as if nothing changed. The client may send a frame using its estimated 
"correct" power level for the AP to receive, while the AP ignores
the frame as the received signal strength is not above the set threshold. This
behaviour may lead to excessive retransmissions and client disconnections in
the worst scenarios, especially at the boundary of the cell coverage where the
asymmetry may be felt the most.
A better result in reducing &lt;em&gt;bidirectionally&lt;/em&gt; the cell size
could have been accomplished by simply reducing the AP transmit power while 
guaranteeing appropriate primary and secondary coverage.
​&lt;/p&gt;
&lt;h2&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;​
Altering the default value of RX-SOP is a risky matter leading to unexpected 
behaviours and interruption of the wireless service if you do not know what
you are trying to accomplish and you do not have a clear picture of the 
mathematics behind signal propagation. 
In general, RX-SOP should not be used without following a well-thought design, 
followed by validation and tuning after the deployment in high-density 
environments with many clients (e.g. auditoriums, stadiums). &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt; -- never shoot off the hip when using RX-SOP, do your
homework with the design, and consider first decreasing power to reduce cell
sizes instead.
​
​
​&lt;/p&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;"High Density Experience (HDX) Deployment Guide, Release 8.0." Cisco, 
   Jun. 2015, https://bit.ly/3oTelUe. Accessed 30 Apr. 2023.&lt;/li&gt;
&lt;li&gt;"Free-space Path Loss." Scholarly Community Encyclopedia, 
   Oct. 2022, https://bit.ly/40WJMdj. Accessed 30 Apr. 2023.&lt;/li&gt;
&lt;li&gt;"Receive Start of Packet (RX-SOP)." Cisco Meraki, 
   Oct. 2020, https://bit.ly/41R9xxa. Accessed 30 Apr. 2023.&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://encyclopedia.pub/entry/31362#:~:text=The%20free%2Dspace%20path%20loss%20(FSPL)%20formula%20derives%20from,%CE%BB%204%20%CF%80%20d%20)%202 --&gt;
&lt;!-- https://www.cisco.com/c/en/us/td/docs/wireless/controller/technotes/8-0/hdx_final/b_hdx_dg_final/high_density_experience_features_added_in_release_8_0.html --&gt;
&lt;!--
https://documentation.meraki.com/MR/Radio_Settings/Receive_Start_of_Packet_(RX-SOP)
--&gt;
&lt;p&gt;​&lt;/p&gt;</content><category term="802.11"></category></entry><entry><title>Troubleshooting WPA2-Enterprise with Meraki Cloud Authentication</title><link href="https://castogio.github.io/troubleshooting-wpa2-enterprise-with-meraki-cloud-authentication.html" rel="alternate"></link><published>2023-04-26T23:00:00+01:00</published><updated>2023-04-26T23:00:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-04-26:/troubleshooting-wpa2-enterprise-with-meraki-cloud-authentication.html</id><summary type="html">&lt;!-- write an introduction --&gt;
&lt;p&gt;I was tinkering in my lab with my ancient MacBook, now running Windows 10, 
a few days ago, looking for ways to simplify my troubleshooting activities at work.
There is a service that the Cisco Meraki access points offer called Meraki 
Cloud Authentication, which offers an authentication server for 802 …&lt;/p&gt;</summary><content type="html">&lt;!-- write an introduction --&gt;
&lt;p&gt;I was tinkering in my lab with my ancient MacBook, now running Windows 10, 
a few days ago, looking for ways to simplify my troubleshooting activities at work.
There is a service that the Cisco Meraki access points offer called Meraki 
Cloud Authentication, which offers an authentication server for 802.1X running
24/7 on their server. It uses the EAP-PEAP/EAP-TLS method to authenticate
users with an email username and a password. &lt;/p&gt;
&lt;p&gt;The email requested by the server is case-sensitive. Unsurprisingly an easy way 
to fail authentication is to write the correct email with one or more 
characters in the wrong case. Another common L8 issue is, of course, typing the
incorrect password because the user forgot it.&lt;/p&gt;
&lt;p&gt;In this blog post, I would like to present some valuable tips to troubleshoot
incorrect authentication credentials using the Event Viewer in Windows 10.
This tool ships natively with the OS, and it provides a step-by-step report of
what is happening when connecting to an SSID, as it allows monitoring 
the service called "&lt;em&gt;WLAN-AutoConfig&lt;/em&gt;," in charge of the 802.11 state machine.&lt;/p&gt;
&lt;h2&gt;Accessing the Event Viewer&lt;/h2&gt;
&lt;p&gt;Let's start by accessing the logs. This is easily done by opening
the Start menu and searching for "Event Viewer." 
You can now navigate as follows in the menu on the left (each section is a 
dropdown item you can unfold):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Applications and Service Logs  &amp;gt; Microsoft &amp;gt; Windows &amp;gt; WLAN-AutoConfig.&lt;/li&gt;
&lt;li&gt;Click on the WLAN-Autoconfig item.&lt;/li&gt;
&lt;li&gt;Right-click on the "Operational" logs and make sure the log is enabled.
   (you will see the button "Disable Log").&lt;/li&gt;
&lt;li&gt;Right-click on the "Operational" logs to make sure you opened the logs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most likely, you will see a list of events in the centre frame of the Event
Viewer; this is normal, and these logs refer to previous operations executed 
by your wireless network card.&lt;/p&gt;
&lt;h2&gt;Dissecting a successful authentication&lt;/h2&gt;
&lt;p&gt;From the perspective of the Client station, there is no difference between a 
server located on-premises or in the cloud. Referring to the sequence diagram
shown below,
the administrator will notice a negligible deviation from what they may expect 
from standard 802.1X authentication processes; however, the actual RADIUS
exchanges are tunnelled between the Meraki APs (MR) and the cloud server.
You will not be able to see the traffic being sent and received on the 
distribution system, as the packets are encrypted.&lt;/p&gt;
&lt;!-- exchange UML --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="meraki cloud auth exchange diagram" src="https://castogio.github.io/images/meraki_auth_troubleshooting/meraki_auth_exchange.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;You can perform a monitor mode packet capture to EAP traffic over the air.
The following exchange can be seen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;There is Identity Request/Response exchange where the client sends 
   the username in clear text (we will not be so lucky with the password).&lt;/li&gt;
&lt;li&gt;The authentication server sends an MD5 request.&lt;/li&gt;
&lt;li&gt;The client rejects it with a Negative Acknowledgement (NAK) and requests
   to use Protected EAP (PEAP).&lt;/li&gt;
&lt;li&gt;The server agrees to use PEAP/EAP-TLS.&lt;/li&gt;
&lt;li&gt;The client and the server perform the encrypted EAP protocol exchanges.&lt;/li&gt;
&lt;li&gt;The server sends an EAP Success message to the client.&lt;/li&gt;
&lt;li&gt;The 4-way RSN handshake can start.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;NOTE: you may notice that the client's wireless MAC address is translated by
Wireshark as "Apple." This is expected as I was running Windows dual-booted
on a MacBook.&lt;/p&gt;
&lt;!-- packet capture success --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="packet capture of EAP success" src="https://castogio.github.io/images/meraki_auth_troubleshooting/SUCCESS_meraki_auth_exchange.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;You can follow the exchanges described above (and more!) in the Event Viewer,
which logs every operation and state transition performed by the 802.11 state 
machine in chronological order from bottom to top (an event lower in the list
happened before the ones on top of it) as you can see in the picture below. 
We will focus on the logs whose Task Category is &lt;em&gt;OneXAuthentication&lt;/em&gt; (i.e. 
they are associated with 802.1X). I highlighted the last 1X event, showing a 
successful authentication and specifying the correct email used as "Identity," 
here shown as "hello@correct.com" (just an example).&lt;/p&gt;
&lt;!-- log success --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="EAP log success on Windows" src="https://castogio.github.io/images/meraki_auth_troubleshooting/capture_success_windows.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;h2&gt;Dissecting a failed authentication&lt;/h2&gt;
&lt;p&gt;Despite what we have seen in the previous section, the operation may not
be smooth when your users report issues with "connecting with the Wi-Fi".
You may not have immediate access to your trusty sidekick
or a different client to collect monitor mode capture. Nonetheless, you can
still open the Event Viewer, ask the user to attempt a connection, see it failing
miserably, and review what is reported in the logs.&lt;/p&gt;
&lt;!-- log failure --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="EAP log failure on Windows" src="https://castogio.github.io/images/meraki_auth_troubleshooting/capture_FAILURE_windows.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;As you can see above, the general structure of the reports mostly stayed the same
when compared to the &lt;em&gt;successful&lt;/em&gt; case. In particular, we can see that the client 
passed the Open Authentication and the Association phases, but it stalled
when attempting the 802.1X operation.&lt;/p&gt;
&lt;p&gt;Opening the log in question (helpfully marked as an "Error"), we can see that
WLAN-AutoConfig reports the fact that this was an &lt;em&gt;explicit&lt;/em&gt; EAP authentication
failure and that we sent the identity "HELLO@correct.com" (which we know is 
incorrect, as seen previously).&lt;/p&gt;
&lt;p&gt;Being in my laboratory, I could take the packet capture and, indeed, all the EAP 
exchanges seen previously show up again, with the sole exception of the last
frame, which contains an EAP failure message (matching what was reported in the
Event Viewer).&lt;/p&gt;
&lt;!-- packet capture failure --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="packet capture of EAP failure" src="https://castogio.github.io/images/meraki_auth_troubleshooting/FAIL_meraki_auth_exchange.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Having been burnt in the past, I recommend you cross-check and confirm the
reports from any facility using additional external tools. In the scenario
described in this post, the Event Viewer correctly pointed to the root cause, 
but it might not be direct regarding more complex problems (also, bugs
are a thing). Seeing an EAP failure in the packet capture confirmed the fact. &lt;/p&gt;
&lt;h2&gt;Conclusion and Lesson Learned&lt;/h2&gt;
&lt;p&gt;The main takeaway of this little demo is "&lt;em&gt;know your tools&lt;/em&gt;".
Client devices offer many built-in programs that will immensely 
simplify your day-to-day as a wireless analyst, especially when 
you cannot access more sophisticated equipment. The Event Viewer is the perfect 
example of a tool that ships with Windows and can show you what the client
is doing, what &lt;strong&gt;it believes&lt;/strong&gt; is going wrong, and potentially, how to 
remediate the issue, as in our case.&lt;/p&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;“Managing User Accounts Using Meraki Cloud Authentication.” 
   Cisco Meraki, Feb. 2023, https://bit.ly/3UQh38T. Accessed 25 Apr. 2023.&lt;/li&gt;
&lt;li&gt;"Event Viewer." Microsoft, 
   Jan. 2019, https://bit.ly/41SfPMC. Accessed 26 Apr. 2023.&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry><entry><title>Demystifying modulation techniques with BPSK</title><link href="https://castogio.github.io/demystifying-modulation-techniques-with-bpsk.html" rel="alternate"></link><published>2023-04-18T22:11:00+01:00</published><updated>2023-04-18T22:11:00+01:00</updated><author><name>Gioacchino Castorio</name></author><id>tag:castogio.github.io,2023-04-18:/demystifying-modulation-techniques-with-bpsk.html</id><summary type="html">&lt;p&gt;The multitude of Modulation and Coding Schemes (MCSs) 
introduced in IEEE802.11 for the VHT and HE PHYs may look like magical 
spells even for the seasoned wireless engineer. At the start of my journey 
as a telecommunications engineer, I was particularly
fascinated by the mathematics behind how to carry …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The multitude of Modulation and Coding Schemes (MCSs) 
introduced in IEEE802.11 for the VHT and HE PHYs may look like magical 
spells even for the seasoned wireless engineer. At the start of my journey 
as a telecommunications engineer, I was particularly
fascinated by the mathematics behind how to carry information from a transmitter
(TX) to a receiver (RX). I believe it might be worth it to take a step back
and get a mathematical intuition of what is happening behind the scenes when 
a STA interacts with the wireless medium.&lt;/p&gt;
&lt;p&gt;Assuming we can transmit the signal wave &lt;em&gt;s(t)&lt;/em&gt;, as in the equation below, where
A is the amplitude, f is the signal frequency, and the time, we could consider
representing 1's as &lt;em&gt;s(t)&lt;/em&gt; and 0's as &lt;em&gt;-s(t)&lt;/em&gt;. &lt;/p&gt;
&lt;!-- s(t) = A*cos(2*pi*f*t) --&gt;
&lt;!-- https://latex.codecogs.com/eqneditor/editor.php --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Simple cosine signal" src="https://castogio.github.io/images/modulation_tech/cosine_base_signal.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The receiver station would immediately recognise what value we are transmitting 
by comparing what is received with the reference signal,
which is assumed to be known. 
The figure below shows the comparison between the reference signal and what can 
be seen at the receiving station, considering path loss exclusively and ignoring
additional effects such as multipath; the picture shows a "one" being received,
followed by a zero.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="periodic" src="https://castogio.github.io/images/modulation_tech/bpsk_periodic_zero_received_vs_reference.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The carrier signal s(t) is not enough to transmit any meaningful
information in real life: the time variable t is an infinite
&lt;a href="https://en.wikipedia.org/wiki/Real_number"&gt;real number&lt;/a&gt; and s(t) repeats
periodically with no start or end in time. We are busy people, and we want
to transmit more than one bit in perpetuity: we can define a new rectangular
function &lt;em&gt;p(t)&lt;/em&gt; which is not-null only for &lt;em&gt;0 &amp;lt;= t &amp;lt;= T&lt;/em&gt;, where &lt;em&gt;T = 1/f&lt;/em&gt; is the
"period" of the signal s(t). &lt;/p&gt;
&lt;!-- 
p(t) =\begin{cases}
      1~if~0 \leq t \leq T\\
      0~otherwise
\end{cases}
--&gt;
&lt;!-- https://latex.codecogs.com/eqneditor/editor.php --&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="rectangular function" src="https://castogio.github.io/images/modulation_tech/rect_function.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Multiplying the two functions &lt;em&gt;g(t) = s(t)p(t)&lt;/em&gt;, we get a limited section of the
the original signal, namely a cycle of the cosine wave.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="Windowed cosine" src="https://castogio.github.io/images/modulation_tech/windowed_signal.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;This signal p(t) is extremely powerful because it lets us move its "windowing" 
effect by simply shifting its "up" value by the period T to the left or right
over the time axis so that p(t-kT) = 1 for kT &amp;lt;= t &amp;lt;= (k+1)T, where k is any
&lt;a href="https://en.wikipedia.org/wiki/Integer"&gt;integer number&lt;/a&gt;. We can shift the
pulse &lt;em&gt;g(t)&lt;/em&gt; by &lt;em&gt;kT&lt;/em&gt; as well.&lt;/p&gt;
&lt;p&gt;The windowed signals can be juxtaposed to represent a sequence of 0's and 1's
fairly easily. The resulting signal can be described mathematically as a
summation &lt;em&gt;S(t)&lt;/em&gt;, where N is the number of windows and the coefficient
&lt;em&gt;c&lt;/em&gt; is 1 when transmitting a "one" bit, -1 otherwise.&lt;/p&gt;
&lt;!-- 
S(t) = \sum_{k=0}^{N-1} c_k*g(t-kT) = \sum_{k=0}^{N-1} c_k*s(t-kT)*p(t-kT)
--&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="pulse train formula" src="https://castogio.github.io/images/modulation_tech/pulse_train_formula.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;The following image shows an example of the application of the above formula
when transmitting a zero followed by a one; the receiver can compare its
local reference to the received signal. Note that this example
considers the existence of some attenuation at RX due to Free Space Path Loss
while ignoring other detrimental effects such as multi-path.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="pulse train plot" src="https://castogio.github.io/images/modulation_tech/bpsk_received_vs_reference.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;You might have noticed that some level of time synchronisation is
needed between the reference and the received signal to allow effective
demodulation. This fact is true regardless of the modulation technique in use,
and it intuitively justifies the existence of preamble sequences in the 
IEEE802.11 PHY Protocol Data Units (PPDUs).&lt;/p&gt;
&lt;p&gt;In conclusion, we managed to transmit a sequence of single bits leveraging the 
simple fact that our RX can discriminate between a positive 
or a negative coefficient for the signal. 
We defined a signal constellation containing two points which are shifted
180 degrees between each other: this technique is commonly referred to as
Binary Phase Shift Keying (BPSK) because the same base carrier &lt;em&gt;s(t)&lt;/em&gt; can 
assume two different phase configurations to represent a single bit.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
    &lt;img alt="pulse train plot" src="https://castogio.github.io/images/modulation_tech/bpsk_constellation.png"&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Intuitively, we can expand the number of transmitted bits by following the same
principles of "tweak a parameter and compare to a reference" as described above.
We will explore Amplitude Shift Keying (ASK), Quadrature Phase Shift Keying
(QPSK), and Quadrature Amplitude Modulation (QAM) in future blog posts.&lt;/p&gt;
&lt;p&gt;Until next time!&lt;/p&gt;
&lt;h3&gt;Bibliography&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Moher, Michael, and S. Haykin. Communication Systems, 5th ed, Chapter 4. 
  Wiley, 2010.&lt;/li&gt;
&lt;li&gt;Carpenter, T. CWAP-404: Certified Wireless Analysis Professional, Chapter 3. 
  Certitrek Publishing, 2021&lt;/li&gt;
&lt;/ul&gt;</content><category term="802.11"></category></entry></feed>